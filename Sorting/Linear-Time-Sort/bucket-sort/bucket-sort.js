/* bucket sort assumes that the input is generated by a
 * random process that distributes elements uniformly and
 * independently over the interval [0, 1). */

var stdIn = require('../../../input'),
  util = require('util'),
  BucketSort = {};

BucketSort.setup = async function setup() {
  this.input_arr = await stdIn.createInputArr();
  this.adj_list = [];
}

BucketSort.headNode = function headNode(head_idx) {
  // head_node : { head: number, free: number, list: [] }
  this.adj_list[head_idx] = { head: null, free: 0 };
  this.adj_list[head_idx].list = [{ next: null }]
}

BucketSort.bucketSort = async function bucketSort () {
  await this.setup();

  Array.apply(null, new Array(10))
    .forEach(function (i, idx) { return this.headNode(idx) }.bind(this));
  /* alternatively,
   * [...Array(10).keys()].map(function (i) { return null }) */

  for (let i = 0; i < this.input_arr.length; i++) {
    // First parameter is the element at index i in input_arr ( key for list ). 
    // Second parameter is the head of bucket.
    // LinkedList.prepend(buck_head_arr, this.input_arr[i], Math.floor(this.input_arr[i] * 10));      
    this.prepend(this.input_arr[i], Math.floor(this.input_arr[i] * 10));
  }

  for (let i = 0; i < this.input_arr.length; i++) {
    if (this.adj_list[i].head !== null) {
      this.sortList(i);
    }
  }

  console.log(util.inspect(this.adj_list, { showHidden: false, depth: null }));

  for (let i = 0; i < this.input_arr.length; i++) {
    if (this.adj_list[i].head !== null) {
      this.printJoinSorted(i);
    }
  }
}  

BucketSort.prepend = function prepend(key, head_idx) {
  // Get free position(index in the list array)
  const freePos = this.allocateObject(head_idx);
  // Initialize an emplty object at freePos
  this.adj_list[head_idx].list[freePos] = {};

  // Set key
  this.adj_list[head_idx].list[freePos].key = key;
  // point next of element being inserted to index where head points
  this.adj_list[head_idx].list[freePos].next = this.adj_list[head_idx].head;
  // point prev of element that head previously pointed to, to index of element being inserted
  if (this.adj_list[head_idx].head !== null) {
    this.adj_list[head_idx].list[this.adj_list[head_idx].head].prev = freePos;
  }
  // point head to index of element being inserted
  this.adj_list[head_idx].head = freePos;
  // prev of first element points to an integer
  // (such -1 or null) that cannot possibly represent an actual index into the arrays.
  this.adj_list[head_idx].list[freePos].prev = -1;
}

BucketSort.allocateObject = function allocateObject(head_idx) {
  const { 
    free, head, list
  } = this.adj_list[head_idx];

  if (this.adj_list[head_idx].list[free].next === null) {
    const free_temp = this.adj_list[head_idx].free;
    this.adj_list[head_idx].free++;

    // sentinel object {next: null}, this is maintained at the end of the list
    this.adj_list[head_idx].list[this.adj_list[head_idx].free] = {};
    this.adj_list[head_idx].list[this.adj_list[head_idx].free].next = null;
    return free_temp;
  } else {
    const free_temp = this.adj_list[head_idx].free;
    this.adj_list[head_idx].free = this.adj_list[head_idx].list[free].next;
    return free_temp;
  }
}

BucketSort.traverse = function traverse(pos) {
  let curr = this.lhead;
  
  while (pos > 1 && this.list[curr].next !== null) {
    curr = this.list[curr].next;
    pos--;
  }

  return curr;
}

BucketSort.sortList = function sortList(head_idx) {
  const {
    head, free, list
  } = this.adj_list[head_idx];

  // First element has no previous node to compare to.
  // Therefore, start at second element in the list and not at first.
  let curr_idx = list[head].next;
  //let pos_idx = list[curr_idx].prev;

  while (curr_idx !== null) {
    let pos_idx = curr_idx;

    // Store next index for next iteration. 
    let next_idx = list[curr_idx].next;

    // Current position node: node reached while searching for key less than current idx node
    while (list[pos_idx].prev !== -1 && list[list[pos_idx].prev].key > list[curr_idx].key) {
      pos_idx = list[pos_idx].prev;
    }

    if (list[pos_idx].prev === -1) {
      /* Current position ( c_p ) will always be the node head initialyy points to. */

      // Point prev of c_p to c_n
      list[pos_idx].prev = curr_idx;

      // Point prev of c_n_n ( Current node next node ) to prev of c_n.
      list[list[curr_idx].next].prev = list[curr_idx].prev;

      // Point next of c_n_p ( Current node previous node ) node to next of c_n.
      list[list[curr_idx].prev].next = list[curr_idx].next;

      // Point next of c_n to previous head, i.e, c_p.
      list[curr_idx].next = this.adj_list[head_idx].head;

      // Make c_n first node in the list.
      list[curr_idx].prev = -1;

      // Update head. Point c_p prev to curr_node.
      this.adj_list[head_idx].head = curr_idx;
    } else {
      // If current node has the largest key value
      if (pos_idx === curr_idx) {
        curr_idx = next_idx;
        continue;
      }

      // Point next of c_n_p ( Current node previous node ) to next of c_n.
      list[list[curr_idx].prev].next = list[curr_idx].next;
    
      // Point next of c_p_p ( Current position previous node ) to c_n.
      list[list[pos_idx].prev].next = curr_idx;
      
      // Point prev of c_n to prev of c_p.
      list[curr_idx].prev = list[pos_idx].prev;

      // Point prev of c_p to c_n.
      list[pos_idx].prev = curr_idx;

      // Point next of c_n to c_p.
      list[curr_idx].next = pos_idx;
    }

    curr_idx = next_idx;
  }

  BucketSort.printJoinSorted = function printJoinSorted(head_idx) {
    const {
      head, list
    } = this.adj_list[head_idx];

    let curr_idx = head;

    while (curr_idx !== null) {
      console.log(list[curr_idx].key);
      curr_idx = list[curr_idx].next;
    }
  }
}

BucketSort.bucketSort();

/* bucket sort assumes that the input is generated by a
 * random process that distributes elements uniformly and
 * independently over the interval [0, 1). */

var stdIn = require('../../../input'),
  ListAsRoutine = require('../../../Linked-List/list-as-routine'),
  util = require('util'),
  BucketSort = Object.create(ListAsRoutine);

BucketSort.setup = async function setup() {
  this.input_arr = await stdIn.createInputArr();
  this.adj_list = [];
}

BucketSort.headNode = function headNode(head_idx) {
  // head_node : { head: number, free: number, list: [] }
  this.adj_list[head_idx] = { head: null, free: 0 };
  this.adj_list[head_idx].list = [{ next: null }]
}

BucketSort.bucketSort = async function bucketSort () {
  await this.setup();

  Array.apply(null, new Array(10))
    .forEach(function (i, idx) { return this.headNode(idx) }.bind(this));
  /* alternatively,
   * [...Array(10).keys()].map(function (i) { return null }) */

  for (let i = 0; i < this.input_arr.length; i++) {
    const { [Math.floor(this.input_arr[i] * 10)]: adjLNode } = this.adj_list;

    // First parameter is the element at index i in input_arr ( key for list ). 
    // Second parameter is the head of bucket.
    // LinkedList.prepend(buck_head_arr, this.input_arr[i], Math.floor(this.input_arr[i] * 10));      
    this.prepend(adjLNode, this.input_arr[i]);
  }

  for (let i = 0; i < 10; i++) {
    if (this.adj_list[i].head !== null) {
      this.sortList(i);
    }
  }

  console.log(util.inspect(this.adj_list, { showHidden: false, depth: null }));

  for (let i = 0; i < 10; i++) {
    if (this.adj_list[i].head !== null) {
      let { [i]: adjLNode } = this.adj_list;
      this.print(adjLNode);
    }
  }
}  

//BucketSort.prepend = function prepend(key, head_idx) {
//  const { [head_idx]: adjLNode } = this.adj_list;
//
//  // Get free position(index in the list array)
//  const freePos = this.allocateObject(head_idx);
//
//  // Initialize an empty object at freePos
//  adjLNode.list[freePos] = {};
//
//  // Set key
//  adjLNode.list[freePos].key = key;
//
//  // point next of element being inserted to index where head points
//  adjLNode.list[freePos].next = adjLNode.head;
//
//  // point prev of element that head previously pointed to, to index of element being inserted
//  if (adjLNode.head !== null) {
//    adjLNode.list[adjLNode.head].prev = freePos;
//  }
//
//  // point head to index of element being inserted
//  adjLNode.head = freePos;
//
//  // prev of first element points to an integer
//  // (such -1 or null) that cannot possibly represent an actual index into the arrays.
//  adjLNode.list[freePos].prev = -1;
//}
//
//BucketSort.allocateObject = function allocateObject(head_idx) {
//  const { [head_idx]: adjLNode } = this.adj_list;
//
//  const { 
//    free, head, list
//  } = adjLNode;
//
//  if (adjLNode.list[free].next === null) {
//    const free_temp = adjLNode.free;
//    adjLNode.free++;
//
//    // sentinel object {next: null}, this is maintained at the end of the list
//    adjLNode.list[adjLNode.free] = {};
//    adjLNode.list[adjLNode.free].next = null;
//    return free_temp;
//  } else {
//    const free_temp = adjLNode.free;
//    adjLNode.free = adjLNode.list[free].next;
//    return free_temp;
//  }
//}

BucketSort.sortList = function sortList(head_idx) {
  const { [head_idx]: adjLNode } = this.adj_list;

  const {
    head, free, list
  } = adjLNode;

  // First element has no previous node to compare to.
  // Therefore, start at second element in the list and not at first.
  let curr_idx = list[head].next;

  while (curr_idx !== null) {
    let pos_idx = curr_idx;

    let { prev: c_n_prev, next: c_n_next, key: c_n_key } = list[curr_idx];

    //let { prev: c_p_prev, next: c_p_next, key: c_p_key } = list[pos_idx];

    // Store next index for next iteration. 
    let next_idx = c_n_next;

    // Current position node: node reached while searching for key less than current idx node
    while (list[pos_idx].prev !== -1 && list[list[pos_idx].prev].key > list[curr_idx].key) {
      pos_idx = list[pos_idx].prev;
    }

    debugger;
    if (list[pos_idx].prev === -1) {
      /* Current position ( c_p ) will always be the node head initialyy points to. */

      // Point prev of c_p to c_n
      list[pos_idx].prev = curr_idx;

      // Point prev of c_n_n ( Current node next node ) to prev of c_n.
      list[c_n_next].prev = c_n_prev;

      // Point next of c_n_p ( Current node previous node ) node to next of c_n.
      list[c_n_prev].next = c_n_next;

      // Point next of c_n to previous head, i.e, c_p.
      c_n_next = adjLNode.head;

      // Make c_n first node in the list.
      c_n_prev = -1;

      // Update head. Point c_p prev to curr_node.
      adjLNode.head = curr_idx;
    } else {
      // If current node has the largest key value
      if (pos_idx === curr_idx) {
        curr_idx = next_idx;
        continue;
      }

      // Point next of c_n_p ( Current node previous node ) to next of c_n.
      list[c_n_prev].next = c_n_next;
    
      // Point next of c_p_p ( Current position previous node ) to c_n.
      list[list[pos_idx].prev].next = curr_idx;
      
      // Point prev of c_n to prev of c_p.
      c_n_prev = list[pos_idx].prev;

      // Point prev of c_p to c_n.
      list[pos_idx].prev = curr_idx;

      // Point next of c_n to c_p.
      c_n_next = pos_idx;
    }

    curr_idx = next_idx;
  }
}

BucketSort.printJoinSorted = function printJoinSorted(head_idx) {
  const { [head_idx]: adjLNode } = this.adj_list;

  const {
    head, list
  } = adjLNode;

  let curr_idx = head;

  while (curr_idx !== null) {
    let { next: c_n_next } = list[curr_idx];
    console.log(list[curr_idx].key);
    curr_idx = c_n_next;
  }
}


BucketSort.bucketSort();
